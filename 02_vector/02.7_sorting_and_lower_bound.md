# 2.7 排序与下界

## 2.7.1 有序性

- 有序性的作用

  极大地提高某些计算的效率.

## 2.7.2 排序及其分类

- 排序分类

  根据其处理数据的规模与存储的特点不同, 可分为内部排序算法和外部排序算法: 前者处
  理的规模相对不大, 内存足以容纳; 后者处理的数据规模很大, 必须将借助外部甚至分布
  式存储器.

  根据输入形式的不同, 排序算法也可分为离线算法和在线算法: 前者待排序的数据以批处
  理的形式整体给出; 而在网络计算之类的环境中, 待排序的数据往往需要实时生成, 在排
  序算法启动后数据才陆续到达.

  针对所依赖的体系结构不同, 可分为串行与并行两大类排序算法.

  根据排序算法是否采用随机策略, 还有确定式和随机式之分.

## 2.7.3 下界

- 复杂度下界

  对任一特定的应用问题, 随着算法的不断改进, 其效率的提高必然存在某一极限.

  一般地, 任一问题在最坏情况下的最低计算成本, 即为该问题的复杂度下界. 一旦某一算
  法的性能达到这一下界, 即意味着它是最坏情况下最优的.

  尽早确定一个问题的复杂度下界, 对相关算法的优化无疑有巨大的裨益.

## 2.7.4 比较树

- 比较树: 一种确定问题复杂度下界的方法

  算法所有可能的执行过程, 都可涵盖于这一树形结构中. 具体地, 该树具有以下性质:
  1. 每一内部节点各对应一次比对操作.
  2. 内部节点的左右分支, 分别对应于两种比对结果下的执行方向.
  3. 叶节点 (或等效地, 根到叶节点的路径) 对应于算法某次执行的完整过程及输出.
  4. 反过来, 算法的每一运行过程都对应于从根到某一叶节点的路径.
  按照上述规则与算法相对应的树, 称为比较树.

  不难理解, 无论什么算法, 只要其中的分支完全取决于不同变量或常量的比对或比较结
  果, 则该算法的所有可能的执行过程都可表示和概括为一颗比较树.

  反之, 凡可如此描述的算法, 都称作基于比较式算法 (CBA 式算法).

## 2.7.5 估计下界

- 最小树高

  考察任一 CBA 式算法 $A$, 设 $CT(A)$ 为与之对应的一棵比较树.

  根据比较树的性质, 算法 $A$ 每一次运行所需的时间, 将取决于其对应叶节点到根节点
  的距离 (称作叶节点的深度); 而算法 $A$ 在最坏情况下的运行时间, 将取决于比较树中
  所有叶节点的最大深度 (称作该树的高度, 记作 $h(CT(A))$).

  因此, 就渐进的意义而言, 算法 $A$ 的时间复杂度不应低于 $\Omega(h(CT(A)))$.

  对于存在 CBA 式算法的计算问题, 由于其任一 CBA 式算法均对应于某棵比较树, 该问题
  的复杂度下界就应等于这些比较树的最小高度.

- 最小树高的计算

  考察比较树中所含叶节点 (可能的输出结果) 的数目. 具体地, 在一棵高度为 $h$ 的二
  叉树中, 叶节点的数目不可能多于 $2^h$. 因此反过来, 若某一问题的输出结果不少于
  $N$ 种, 则比较树中叶节点也不可能少于 $N$ 个, 树高 $h$ 不可能低于 $\log_2 N$.
