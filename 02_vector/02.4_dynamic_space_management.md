# 2.4 动态空间管理

## 2.4.1 静态空间管理

- 静态空间管理

  内部数组所占物理空间的容量, 若在其生命周期内不允许调整, 则称为静态空间管理策
  略.

  静态空间管理的空间效率难以保证:

  - 上溢: 容量固定, 总有可能在此后某一时刻, 无法加入更多的新元素.
  - 即便愿意为降低风险而预留出部分空间, 也很难在程序执行前, 明确界定一个合理的预
    留量.

- 装填因子

  向量的实际规模与其内部数组容量的比值 ($_size / _capacity$), 它是衡量空间利用率
  的重要指标.

## 2.4.2 可扩充向量

- 扩充向量

  若内部数组仍有空余, 则操作仍可照常执行. 每经过一次插入 (删除), 可用空间都会减
  少 (增加) 的一个单元. 一旦可用空间耗尽, 就动态地扩大内部数组的容量.

  问题在于: 如何实现扩容? 新的容量取作多少才算适宜?

  一种可行的方法: 另行申请一个容量更大的数组, 并将原数组中的成员集体搬迁至新的
  空间, 释放原数组所占的空间.

## 2.4.3 扩容

- 向量扩容算法

  ```cpp
  template <typename T>
  void Vector<T>::expand() {
    if (_size < _capacity)  // 尚未满员时, 不必扩容
      return;
    if (_capacity < DEFAULT_CAPACITY) // 不低于最小容量
      _capacity = DEFAULT_CAPACITY;

    T* oldElem = _elem;
    _elem = new T[_capacity <<= 1];
    for (int i = 0; i < _size; ++i) // 复制原向量内容 (T 为基本类型, 或已重载赋值操作符 '=')
      _elem[i] = oldElem[i];
    delete[] oldElem; // 释放原空间
  }
  ```

  新数组的容量总是取作原数组的两倍.

## 2.4.4 分摊分析

- 时间代价

  随着向量规模的不断扩大, 在执行插入操作前需要进行扩容的概率也将迅速降低. 故就某
  种平均意义而言, 用于扩容的时间成本不至于很高.

- 分摊运行时间

  对可扩充向量做足够多次连续操作, 并将其间所消耗的时间, 分摊至所有的操作.

  不同于平均运行时间, 分摊运行时间要求参与分摊的操作必须构成和来自一个真实可行的
  足够长的操作序列.

- $O(1)$ 分摊时间

  假定数组的初始容量为某一常数 $N$. 既然是估计复杂度的上界, 故不妨设向量的初始规
  模也为 $N$ 即将溢出. 另外不难看出, 除插入操作外, 向量其余的接口操作既不会直接
  导致溢出, 也不会增加此后溢出的可能性, 因此不妨考查最坏的情况, 假设在此后需要连
  续地进行 $n$ 次 insert()操作, $n \gg N$.首先定义如下函数

  - $size(n)$: 连续插入 $n$ 个元素后向量的规模.
  - $capacity(n)$: 连续插入 $n$ 个元素后数组的容量.
  - $T(n)$: 为连续插入 $n$ 个元素而花费于扩容的时间.

  其中, 向量规模从 $N$ 开始随着操作的进程逐步递增, 故有:

  $$
  size(n) = N + n;
  $$

  既然不至于溢出, 故装填因子不超过 100%. 同时, 扩容采用了 "懒惰" 策略: 只有在的
  确即将发生溢出时, 才不得不将容量加倍. 因此装填因子也始终不低于 50%.

  综上, 始终有

  $$
  size(n) \leqslant capacity(n) < 2 \cdot size(n).
  $$

  考虑到 $N$ 为常数, 故有

  $$
  capacity(n) = \Theta(size(n)) = \Theta(n)
  $$

  容量以 2 为比例按指数速度增长, 在容量达到 $capacity(n)$ 之前, 共做过
  $\Theta(\log_2 n)$ 次扩容, 每次扩容所需时间线性正比于当时的容量 (或规模), 且同
  样以 2 为比例按指数速度增长. 因此, 消耗于扩容的时间累计不过:

  $$
  T(n) = 2N + 4N + 8N + \cdots + capacity(n) < 2 \cdot capacity(n) = \Theta(n).
  $$

  将其分摊到其间的连续 $n$ 次操作, 单次操作所需的分摊运行时间应为 $O(1)$.

- 其他扩容策略

  并非任何扩容策略都能保证如此高的效率: "一旦有必要, 追加固定数目的单元" 这一扩
  容策略, 无论采用多大的固定常数, 在最坏情况下, 此类数组单次操作的分摊时间复杂度
  都将高达 $\Omega(n)$.

## 2.4.5 缩容

- 下溢

  当装填因子低于某一阈值时, 我们称数组发生了下溢.

  在格外关注空间利用率的场合, 发生下溢也有必要适当缩减内部数组容量.

- 向量缩容算法

  ```cpp
  template <typename T>
  void Vector<T>::shrink() {
    if (_capacity < DEFAULT_CAPACITY << 1)  // 不至于收缩到 DEFAULT_CAPACITY 以下
      return;
    if (_size << 2 > _capacity) // 以 25 % 为界
      return;
  
    T* oldElem = _elem;
    _elem = new T[_capacity >>= 1]; // 容量减半
    for (int i = 0; i < _size; ++i) // 复制原向量内容
      _elem[i] = oldElem[i];
    delete[] oldElem;
  }
  ```

  类似于 expand() 操作, 其分摊复杂度亦为 $O(1)$.

  当然, 就单次扩容 (缩容) 操作而言, 所需的时间确实会高达 $\Omega(n)$, 因此在对单
  次操作的执行速度非常敏感的应用场合, 以上策略并不适用.
