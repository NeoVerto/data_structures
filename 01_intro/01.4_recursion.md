# 1.4 递归

- 什么是递归

  允许函数和过程进行自我调用.

- 递归的价值

  许多应用问题可简洁而准确地描述为递归形式.

  递归也是一种基本而典型的算法设计模式, 可对实际问题中反复出现的结构和形式做高度
  概况, 并从本质层面加以描述与刻画, 进而导出高效的算法.

  从程序结构的角度看, 递归模式能够统筹纷繁多变的具体情况, 避免复杂的分支和嵌套的
  循环, 从而更为简明地描述和实现算法, 减少代码量, 提高算法的可读性, 保证算法的整
  体效率.

## 1.4.1 线性递归

- 数组求和

  ```cpp
  // 数组求和算法 (线性递归版)
  int sum(int A[], int n) {
    if (n < 1)                          // 平凡情况, 递归基
      return 0;                         // 直接 (非递归式) 计算
    else                                // 一般情况
      return sum(A, n - 1) + A[n - 1];  // 递归: 前 n - 1 项和 + 第 n - 1 项.
  }
  ```

- 递归设计技巧

  保证递归算法有穷性的基本技巧: 首先判断并处理 $n = 0$ 之类的平凡情况, 以免因无
  限递归导致系统溢出.

  这类平凡情况统称为 "递归基". 平凡情况可能有多种, 但至少要有一种, 且迟早会出现.

- 线性递归

  每一递归实例对自身的调用至多一次. 每一层次上至多只有一个实例, 构成一个线性的次
  序关系.

  这种形式中, 应用问题总能分解为两个独立的子问题: 其一对应于单独的某个元素, 故可
  直接求解; 另一个对应于剩余部分, 且其结构与原问题相同. 另外, 子问题的解经过简单
  的合并后, 即可得到原问题的解.

- 减而治之

  递归每深入一层, 待求解的问题规模都缩减为一个常数, 直至最终退化为平凡的小
  (简单) 问题.

## 1.4.2 递归分析

- 递归跟踪

  按照以下原则, 将递归算法的执行过程整理为图的形式:

  1. 算法的每一递归实例都表示为一个方框, 其中注明了该实例调用的参数
  2. 若实例 M 调用实例 N, 则在二者对应的方框之间添加一条有向联线.

  整个算法所需的计算时间, 应等于所有递归实例的创建, 执行和销毁所需的时间总和. 其
  中, 递归实例的创建, 销毁均由操作系统负责完成, 其对应的时间成本通常可以近似为常
  数, 不会超过递归实例中实质计算步骤所需的时间成本, 故往往均予忽略. 为便于估算,
  启动各实例的每一条递归调用语句所需的时间, 也可以计入被创建的递归实例上. 综上,
  我们只需统计各递归实例中非递归调用部分所需的时间.

- 递推方程

  通过对递归模式的数学归纳, 导出复杂度定界函数的递推方程 (组) 及其边界条件, 从而
  将复杂度的分析转化为递归方程 (组) 的求解.

  边界条件可通过分析递归基可得.

## 1.4.3 递归模式

- 多递归基

  为保证有穷性, 递归算法都必须设置递归基, 且确保总能执行到. 为此, 应针对每一类可
  能出现的平凡情况, 设置对应的递归基.

- 实现递归

  在设计递归算法时, 往往要从多个角度反复尝试, 方能确定对问题的输入及其规模的最佳
  划分方式. 有时, 还可能需要从不同的角度重新定义和描述原问题, 使得经分解所得的子
  问题与原问题具有相同的语义形式.

- 多向递归

  递归算法中, 不仅递归基可能有多个, 递归调用也可能有多种可供选择的分支.

  每一递归实例虽然有多个可能的递归方向, 但只能从中选择其一, 故各个层次上的递归实
  例依然构成一个线性次序关系, 仍属于线性递归.

  ```cpp
  // 幂函数 2^n 算法 (优化递归版), n >= 0
  int64_t power2(int n) {
    if (0 == n) // 递归基
      return 1;
    // 视 n 的奇偶性分别递归
    return (n & 1) ? sqr(power2(n >> 1)) << 1 : sqr(power2(n >> 1));
  }
  ```

## 1.4.4 递归消除

- 空间成本

  较迭代版, 算法的递归版本通常需要耗费更多空间, 进而影响其实际的运行速度.

  就操作系统而言, 为实现递归调用往往需要花费大量额外时间以创建, 维护和销毁各递归
  实例, 这也会令计算的负担雪上加霜.

- 尾递归及其消除

  在线性递归算法中, 若递归调用在递归实例中恰好以最后一步操作的形式出现, 则称为尾
  递归.

  以 reverse(A, lo, hi) 算法为例:

  ```cpp
  // 数组倒置 (直接改造而得到的迭代版)
  void reverse(int* A, int lo, int hi) {
  next: // 算法起始位置添加跳转标志
    if (lo < hi) {
      swap(A[lo], A[hi]);
      ++lo; --hi; // 收缩待倒置区间
      goto next;  // 跳转到算法体的起始位置, 迭代地倒置 A(lo, hi)
    } // else 隐含了迭代的终止.
  }
  ```

  ```cpp
  // 数组倒置 (规范整理后的迭代版)
  void reverse(int* A, int lo, int hi) {
    while (lo < hi) // 用 while 替换跳转标志与 if, 完全等效.
      swap(A[lo++], A[hi--]);
  }
  ```

## 1.4.5 二分递归

- 分而治之

  将大问题分解为若干规模更小的子问题, 通过递归机制分别求解. 这种分解持续进行, 直
  至子问题规模缩减至平凡情况.

  要求对原问题重新表述, 以保证子问题与原问题在接口上的一致.

- 多路递归

  每一递归实例可能做多次递归.

  二分递归将原问题一分为二, 并分别做递归.

- 数组求和

  ```cpp
  // 数组求和算法 (二分递归版, 入口为 sum(A, 0, n - 1))
  int sum(int A[], int lo, int hi) {
    if (lo == hi)   // 如遇递归基, 则
      return A[lo]; // 直接返回该元素
    else {          // 否则 (一般情况下 lo < hi),
      int mi = (lo + hi) >> 1;  // 以居中单元为界, 将原区间一分为二
      return sum(A, lo, mi) + sum(A, mi + 1, hi); // 递归对各子数组求和, 然后合计
    }
  }
  ```

- 效率

  为使分治策略真正有效, 不仅必须保证子问题划分与子解答合并两方面的计算都能高效地
  实现, 还必须保证子问题之间相互独立.

  以 Fibonacci 数的二分递归做反面例子:

  ```cpp
  // 计算 Fibonacci 数列的第 n 项 (二分递归版)
  int64_t fib(int n) {
    return (2 > n) ?
          (int64_t)n  // 若到达递归基, 直接取值
          : fib(n - 1) + fib(n - 2);  // 否则, 递归计算前两项, 其和为正解.
  }
  ```

  该算法需要运行 $O(2^n)$ 时间才能计算出第 $n$ 个 Fibonacci 数. 原因在于计算过程
  中出现的递归实例的重复度极高.

- 优化策略

  为消除递归算法中重复的递归实例, 一种自然而然的思路与技巧可概括为: **借助一定量
  的辅助空间, 在各子问题求解后, 及时记录下对应的解答.**

  - 制表 (记忆) 策略: 从原问题出发自顶向下, 每遇到一个子问题, 都首先查验其是否计
    算过, 以期望通过直接调阅记录获得解答, 从而避免重复计算.

    以 Fibonacci 数的线性递归实现为例:

    ```cpp
    // 计算 Fibonacci 数列第 n 项 (线性递归版): 入口形式 fib(n, prev)
    int64_t fib(int n, int64_t& prev) {
      if (0 == n) { // 若到达递归基, 则
        prev = 1;   // 直接取值: fib(-1) = 1, fib(0) = 0;
        return 0;
      }
      else {        // 否则
        int64_t prevPrev; // 递归计算前两项
        prev =  fib(n - 1, prevPrev);
        return prev + prevPrev; // 其和即为正解.
      }
    }
    ```

    通过变量 $prevPrev$, 可调阅此前的记录, 从而省略掉 fib(n - 2) 递归.

  - 动态规划策略: 从递归基出发, 自底向上递推地得到各子问题的解, 直至最终原问题的
    解.

    以 Fibonacci 数的迭代实现为例:

    ```cpp
    // 计算 Fibonacci 数列的第 n 项 (迭代版)
    int64_t fibI(int n) {
      int64_t f = 0, g = 1; // 初始化: fib(0) = 0, fib(1) = 1;
      while (0 < n--) { // 依据原始定义, 通过 n 次加法与减法计算 fib(n)
        g += f;
        f = g - f;
      }
      return f;
    }
    ```

    由线性递归版 fib() 算法可见, 其所记录的每个子问题的解答, 只会用到一次. 在该
    算法抵达递归基之后的逐层返回过程中, 每向上返回一层, 其下各层的解答均不必继续
    保留.

    因此, 若将以上逐层返回的过程, 等效地视作从递归基出发, 按规模自小而大求解子问
    题的过程, 即可采用动态规划的策略.
