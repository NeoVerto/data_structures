# 1.1 计算机与算法

- 计算机科学的核心

  计算机科学的核心在于研究计算方法与过程的规律. E. Dijkstra 更倾向于称之为计算科
  学.

## 1.1.3 起泡排序

- 排序

  按照某种约定的次序, 将给定的一组元素顺序排列.

  D. Knuth 指出, 1 / 4 以上的 CPU 时间都用于排序.

- 顺序与逆序

  由一组整数组成的序列 $A[0, n - 1]$ 中, 满足 $A[i - 1] \leqslant A[i]$ 的相邻元
  素称作顺序的; 否则是逆序的.

- 局部有序与整体有序

  有序序列的每一对相邻元素都是顺序的; 反之, 所有相邻元素均顺序的序列, 也必然整体
  有序.

- 扫描交换

  依据: 由有序序列的上述特征, 我们可以通过不断改善局部的有序性实现整体的有序.

  实现: 从前向后依次检查每一对相邻元素, 一旦发现逆序就交换二者的位置.

  性能: 对长度为 $n$ 的序列, 共需做 $n - 1$ 次比较和不超过 $n - 1$ 次交换.

- 起泡排序

  反复进行多次扫描交换, 直到序列整体有序.

  ```cpp
  void bubblesort1A(int A[], int n) {
    bool sorted = false;            // 整体排序标志: 首先假定尚未排序
    while (!sorted) {               // 尚未确认已全局排序前, 逐趟进行扫描交换
      sorted = true;                // 假定已经排序
  
      for (int i = 1; i < n; ++i) { // 自左向右逐对检查当前范围 A[0, n) 内的各相邻元素
        if (A[i - 1] > A[i]) {      // 一旦 A[i - 1] 与 A[i] 逆序, 则
          swap(A[i - 1], A[i]);     // 交换之, 并
          sorted = false;           // 由于整体有序无法保证, 清除排序标志
        }
      }
  
      --n;                          // 末元素必然就位, 可缩短排序序列的有效长度.
    } // 借助布尔型标志位 sorted, 可提前退出, 而非总是蛮力地做 n - 1 趟扫描交换
  }
  ```

## 1.1.4 算法

- 算法

  基于特定的计算模型, 旨在解决某一信息处理问题而设计的一个指令序列.

- 输入与输出

  对所求解问题特定实例的描述统称为输入.

  经计算和处理之后得到的信息, 即针对输入问题实例的答案, 称作输出.

- 基本操作, 确定性与可行性

  确定性和可行性是指, 算法应可描述为由若干语义明确的基本操作组成的指令序列, 且每
  一基本操作在对应的计算模型中均可兑现.

- 有穷性与正确性

  任意算法都应在执行有限次基本操作之后终止并给出输出, 此即所谓算法的有穷性.

  算法不仅应该迟早会终止, 而且所给的输出还应该能够符合由问题本身在事先确定的条
  件, 此即所谓算法的正确性.

- 证明有穷性与正确性

  重要技巧: 从适当的角度审视整个计算过程, 并找出其所具有的某种不变性和单调性. 单
  调性通常指问题的有效规模会随着算法的推进不断递减. 不变性不仅应在算法的初始状态
  下自然满足, 且当问题的有效规模缩减到 0 时, 不变性应随即等价于正确性.

  以起泡排序为例: 起泡排序算法的不变性与单调性可分别概括为: 经过 $k$ 趟扫描交换
  后, 最大的前 $k$ 个元素必然就位; 经过 $k$ 趟扫描交换后, 待求解问题的有效规模将
  缩减至 $n - k$.

- 退化与鲁棒性

  退化情况: 各种极端的输入实例.

  鲁棒性: 能够尽可能充分地应对退化情况的性质.

- 重用性

  算法的总体框架是否能够便捷地推广至其他场合.

## 1.1.5 算法效率

- 可计算性

  所能用算法解决的问题, 其必须满足可计算性.

- 难解性

  即便问题可以通过算法解决, 但其最低求解时间成本远超出实际系统所能提供的计算能
  力. 这被称为难解性.

- 数据结构

  无论是算法的初始输入, 中间结果还是最终输出, 在计算机中都通过数据的形式表示. 对
  数据的操作的执行效率将直接影响和决定算法的整体效率.
